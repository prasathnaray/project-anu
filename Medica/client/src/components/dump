import React, { useEffect, useRef, useState } from "react";
import { Stage } from "amazon-ivs-web-broadcast";
import { jwtDecode } from "jwt-decode";

export default function IvsSubscriber() {
  const videoRef = useRef(null);
  const stageRef = useRef(null);
  const [error, setError] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isStreamActive, setIsStreamActive] = useState(false);
  const [debugInfo, setDebugInfo] = useState("");

  useEffect(() => {
    console.log("Component mounted, videoRef:", videoRef.current);
    setDebugInfo("Component mounted");

    async function joinAsSubscriber() {
      try {
        setIsLoading(true);
        setDebugInfo("Getting token...");
        
        // 1️⃣ Get token
        const tokenn = localStorage.getItem("user_token");
        if (!tokenn) throw new Error("No user token found");

        const decoded = jwtDecode(tokenn);
        const userMail = decoded.user_mail;

        const res = await fetch("http://localhost:4004/api/v1/tokenn", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            stageArn: "arn:aws:ivs:ap-south-1:299822065337:stage/zFMYIVZchIZO",
            userId: userMail,
            capabilities: ["SUBSCRIBE"]
          }),
        });

        if (!res.ok) {
          throw new Error(`Token fetch failed: ${res.status} ${res.statusText}`);
        }

        const data = await res.json();
        const token = data.result.data.token;
        if (!token) throw new Error("No token received from backend");

        setDebugInfo("Token received, initializing stage...");

        // 2️⃣ Initialize Stage
        const stage = new Stage(token, {
          shouldSubscribeToParticipant: (participant) => {
            console.log("Should subscribe to participant:", participant);
            setDebugInfo(`Considering subscription to: ${participant.userId}`);
            return true;
          },
          
          getSubscribeConfiguration: (participant) => ({
            video: true,
            audio: true,
          }),
        });
        stageRef.current = stage;
        // 3️⃣ Handle ALL stage events - FIXED VERSION
        stage.on("connected", () => {
          console.log("Connected to IVS stage");
          setDebugInfo("Connected to IVS stage");
        });
        stage.on("streamAdded", (remoteStream) => {
          console.log("Stream added:", remoteStream);
          setDebugInfo(`Stream added from: ${remoteStream.participantId}`);
          setIsStreamActive(true);
          if (!videoRef.current) {
            console.error("videoRef is null");
            setDebugInfo("ERROR: videoRef is null");
            return;
          }
          const videoTracks = remoteStream.mediaStream.getVideoTracks();
          const audioTracks = remoteStream.mediaStream.getAudioTracks();
          console.log("Video tracks:", videoTracks);
          console.log("Audio tracks:", audioTracks);
          setDebugInfo(`Video tracks: ${videoTracks.length}, Audio tracks: ${audioTracks.length}`);
          if (videoTracks.length > 0) {
            console.log("Attaching video stream");
            setDebugInfo("Attaching video stream to video element");
            // Remove any existing stream first
            if (videoRef.current.srcObject) {
              videoRef.current.srcObject.getTracks().forEach(track => track.stop());
              videoRef.current.srcObject = null;
            }
            
            // ✅ FIXED: Use the correct Amazon approach
            videoRef.current.srcObject = new MediaStream();
            
            // Add video tracks
            videoTracks.forEach(track => {
              videoRef.current.srcObject.addTrack(track);
            });
            
            // Add audio tracks
            audioTracks.forEach(track => {
              videoRef.current.srcObject.addTrack(track);
            });
            
            const playPromise = videoRef.current.play();
            
            if (playPromise !== undefined) {
              playPromise
                .then(() => {
                  console.log("Video playing successfully");
                  setDebugInfo("Video playing successfully");
                  setIsLoading(false);
                  setError(null);
                })
                .catch(err => {
                  console.error("Autoplay failed:", err);
                  setDebugInfo(`Autoplay failed: ${err.message}`);
                  setError("Click to play video");
                });
            }
          } else {
            setDebugInfo("No video tracks in stream");
            setError("Stream has no video content");
          }
        });

        stage.on("streamRemoved", (remoteStream) => {
          console.log("Remote stream removed:", remoteStream);
          setDebugInfo(`Stream removed: ${remoteStream.participantId}`);
          setIsStreamActive(false);
          if (videoRef.current?.srcObject) {
            videoRef.current.srcObject.getTracks().forEach(track => track.stop());
            videoRef.current.srcObject = null;
            setError("Stream ended");
          }
        });

        stage.on("participantJoined", (participant) => {
          console.log("Participant joined:", participant);
          setDebugInfo(`Participant joined: ${participant.userId}`);
        });

        stage.on("participantLeft", (participant) => {
          console.log("Participant left:", participant);
          setDebugInfo(`Participant left: ${participant.userId}`);
        });

        stage.on("error", (err) => {
          console.error("Stage error:", err);
          setDebugInfo(`Stage error: ${err.message}`);
          setError(`Stage error: ${err.message}`);
        });

        // 4️⃣ Join stage
        setDebugInfo("Joining stage...");
        await stage.join();
        console.log("Successfully joined stage");
        setDebugInfo("Successfully joined stage");
        
      } catch (err) {
        console.error("Failed to join stage:", err);
        setDebugInfo(`Failed to join: ${err.message}`);
        setError(`Failed to join: ${err.message}`);
        setIsLoading(false);
      }
    }

    joinAsSubscriber();

    // Cleanup on unmount
    return () => {
      if (stageRef.current) {
        stageRef.current.leave();
        console.log("Left the stage");
        setDebugInfo("Left the stage");
      }
      if (videoRef.current && videoRef.current.srcObject) {
        videoRef.current.srcObject.getTracks().forEach(track => track.stop());
        videoRef.current.srcObject = null;
      }
    };
  }, []);

  const handleVideoClick = () => {
    if (videoRef.current) {
      setDebugInfo("Manual play attempt");
      videoRef.current.play()
        .then(() => {
          console.log("Video started by user interaction");
          setDebugInfo("Video started by user interaction");
          setError(null);
        })
        .catch(err => {
          console.error("Still cannot play video:", err);
          setDebugInfo(`Manual play failed: ${err.message}`);
          setError("Cannot play video. Check permissions.");
        });
    }
  };

  return (
    <div className="flex justify-center items-center h-screen bg-gray-100 relative">
      {isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 z-10">
          <div className="text-white">Connecting to stream...</div>
        </div>
      )}
      
      <video
        ref={videoRef}
        autoPlay
        playsInline
        muted={true}
        className="w-full max-w-[800px] h-auto border bg-black"
        controls={false}
        onClick={handleVideoClick}
      />
      
      {error && !isStreamActive && (
        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white z-20">
          <div className="text-center">
            <p>{error}</p>
            <p className="text-sm mt-2">Waiting for video stream</p>
          </div>
        </div>
      )}
      
      {error && isStreamActive && (
        <div 
          className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white cursor-pointer z-20"
          onClick={handleVideoClick}
        >
          <div className="text-center">
            <p>{error}</p>
            <p className="text-sm mt-2">Click to play video</p>
          </div>
        </div>
      )}
      
      {/* Debug panel */}
      <div className="absolute top-4 left-4 bg-black bg-opacity-70 text-white p-3 rounded text-xs max-w-md z-30">
        <div className="font-bold mb-2">Debug Info:</div>
        <div className="overflow-auto max-h-32">{debugInfo}</div>
        <div className="mt-2">
          Status: {isLoading ? "Connecting..." : isStreamActive ? "Streaming" : "Connected"}
        </div>
      </div>
    </div>
  );
}



//better than above code 


//better than before
import React, { useEffect, useRef, useState } from "react";
import { Stage } from "amazon-ivs-web-broadcast";
import { jwtDecode } from "jwt-decode";

export default function IvsSubscriber() {
  const videoRef = useRef(null);
  const stageRef = useRef(null);
  const [error, setError] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isStreamActive, setIsStreamActive] = useState(false);
  const [debugInfo, setDebugInfo] = useState("");

  useEffect(() => {
    console.log("Component mounted, videoRef:", videoRef.current);
    setDebugInfo("Component mounted");

    async function joinAsSubscriber() {
      try {
        setIsLoading(true);
        setDebugInfo("Getting token...");
        
        // 1️⃣ Get token
        const tokenn = localStorage.getItem("user_token");
        if (!tokenn) throw new Error("No user token found");

        const decoded = jwtDecode(tokenn);
        const userMail = decoded.user_mail;

        const res = await fetch("http://localhost:4004/api/v1/tokenn", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            stageArn: "arn:aws:ivs:ap-south-1:299822065337:stage/zFMYIVZchIZO",
            userId: userMail,
            capabilities: ["SUBSCRIBE"]
          }),
        });

        if (!res.ok) {
          throw new Error(`Token fetch failed: ${res.status} ${res.statusText}`);
        }

        const data = await res.json();
        const token = data.result.data.token;
        if (!token) throw new Error("No token received from backend");

        setDebugInfo("Token received, initializing stage...");

        // 2️⃣ Initialize Stage
        const stage = new Stage(token, {
          shouldSubscribeToParticipant: (participant) => {
            console.log("Should subscribe to participant:", participant);
            setDebugInfo(`Considering subscription to: ${participant.userId}`);
            return true;
          },
          
          getSubscribeConfiguration: (participant) => ({
            video: true,
            audio: true,
          }),
        });
        stageRef.current = stage;
        // 3️⃣ Handle ALL stage events - FIXED VERSION
        stage.on("connected", () => {
          console.log("Connected to IVS stage");
          setDebugInfo("Connected to IVS stage");
        });
        stage.on("streamAdded", (remoteStream) => {
          console.log("Stream added:", remoteStream);
          setDebugInfo(`Stream added from: ${remoteStream.participantId}`);
          setIsStreamActive(true);
          if (!videoRef.current) {
            console.error("videoRef is null");
            setDebugInfo("ERROR: videoRef is null");
            return;
          }
          const videoTracks = remoteStream.mediaStream.getVideoTracks();
          const audioTracks = remoteStream.mediaStream.getAudioTracks();
          console.log("Video tracks:", videoTracks);
          console.log("Audio tracks:", audioTracks);
          setDebugInfo(`Video tracks: ${videoTracks.length}, Audio tracks: ${audioTracks.length}`);
          if (videoTracks.length > 0) {
            console.log("Attaching video stream");
            setDebugInfo("Attaching video stream to video element");
            // Remove any existing stream first
            if (videoRef.current.srcObject) {
              videoRef.current.srcObject.getTracks().forEach(track => track.stop());
              videoRef.current.srcObject = null;
            }
            
            // ✅ FIXED: Use the correct Amazon approach
            videoRef.current.srcObject = new MediaStream();
            
            // Add video tracks
            videoTracks.forEach(track => {
              videoRef.current.srcObject.addTrack(track);
            });
            
            // Add audio tracks
            audioTracks.forEach(track => {
              videoRef.current.srcObject.addTrack(track);
            });

              console.log("Attached video srcObject:", videoRef.current);
            
            const playPromise = videoRef.current.play();
            
            if (playPromise !== undefined) {
              playPromise
                .then(() => {
                  console.log("Video playing successfully");
                  setDebugInfo("Video playing successfully");
                  setIsLoading(false);
                  setError(null);
                })
                .catch(err => {
                  console.error("Autoplay failed:", err);
                  setDebugInfo(`Autoplay failed: ${err.message}`);
                  setError("Click to play video");
                });
            }
          } else {
            setDebugInfo("No video tracks in stream");
            setError("Stream has no video content");
          }
        });

        stage.on("streamRemoved", (remoteStream) => {
          console.log("Remote stream removed:", remoteStream);
          setDebugInfo(`Stream removed: ${remoteStream.participantId}`);
          setIsStreamActive(false);
          if (videoRef.current?.srcObject) {
            videoRef.current.srcObject.getTracks().forEach(track => track.stop());
            videoRef.current.srcObject = null;
            setError("Stream ended");
          }
        });

        // stage.on("participantJoined", (participant) => {
        //   console.log("Participant joined:", participant);
        //   setDebugInfo(`Participant joined: ${participant.userId}`);
        // });

        // stage.on("participantLeft", (participant) => {
        //   console.log("Participant left:", participant);
        //   setDebugInfo(`Participant left: ${participant.userId}`);
        // });  
stage.on("participantJoined", (participant) => {
  console.log("Participant joined:", participant.userId);
  setDebugInfo(`Participant joined: ${participant.userId}`);

  // 🔑 Subscribe to new tracks from this participant
  participant.on("trackPublished", (track) => {
    console.log("Track published:", track.kind);

    track.on("subscribed", () => {
      console.log("Track subscribed:", track.kind);

      if (track.kind === "video" && videoRef.current) {
        // Attach the video stream
        console.log("Attaching full mediaStream directly")
        videoRef.current.srcObject = track.mediaStream;

        console.log("Video element srcObject:", videoRef);
        console.log("ReadyState:", videoRef.current.readyState);
        videoRef.current
          .play()
          .then(() => console.log("Video should be playing"))
          .catch((err) => {
            console.error("Autoplay blocked:", err);
            setError("Click video to play");
          });
      }

      if (track.kind === "audio" && videoRef.current?.srcObject) {
        // Add audio to the same stream
        const currentStream = videoRef.current.srcObject;
        currentStream.addTrack(track.mediaStream.getAudioTracks()[0]);
      }


      // if (!videoRef.current) return;

      // if (track.kind === "video") {
      //   // Attach the video stream directly
      //   videoRef.current.srcObject = track.mediaStream;

      //   videoRef.current
      //     .play()
      //     .then(() => console.log("Video playing ✅"))
      //     .catch((err) => {
      //       console.error("Autoplay blocked ❌", err);
      //       setError("Click video to play");
      //     });
      // }

      // if (track.kind === "audio") {
      //   // Merge audio into the same stream
      //   const currentStream = videoRef.current.srcObject || new MediaStream();
      //   const [audioTrack] = track.mediaStream.getAudioTracks();
      //   if (audioTrack) currentStream.addTrack(audioTrack);
      //   videoRef.current.srcObject = currentStream;
      // }
    });
  });
});

stage.on("participantLeft", (participant) => {
  console.log("Participant left:", participant.userId);
  setDebugInfo(`Participant left: ${participant.userId}`);

  if (videoRef.current?.srcObject) {
    videoRef.current.srcObject.getTracks().forEach(track => track.stop());
    videoRef.current.srcObject = null;
  }
});



        stage.on("error", (err) => {
          console.error("Stage error:", err);
          setDebugInfo(`Stage error: ${err.message}`);
          setError(`Stage error: ${err.message}`);
        });

        // 4️⃣ Join stage
        setDebugInfo("Joining stage...");
        await stage.join();
        console.log("Successfully joined stage");
        setDebugInfo("Successfully joined stage");
        
      } catch (err) {
        console.error("Failed to join stage:", err);
        setDebugInfo(`Failed to join: ${err.message}`);
        setError(`Failed to join: ${err.message}`);
        setIsLoading(false);
      }
    }

    joinAsSubscriber();

    // Cleanup on unmount
    return () => {
      if (stageRef.current) {
        stageRef.current.leave();
        console.log("Left the stage");
        setDebugInfo("Left the stage");
      }
      if (videoRef.current && videoRef.current.srcObject) {
        videoRef.current.srcObject.getTracks().forEach(track => track.stop());
        videoRef.current.srcObject = null;
      }
    };
  }, []);

  const handleVideoClick = () => {
    if (videoRef.current) {
      setDebugInfo("Manual play attempt");
      videoRef.current.play()
        .then(() => {
          console.log("Video started by user interaction");
          setDebugInfo("Video started by user interaction");
          setError(null);
        })
        .catch(err => {
          console.error("Still cannot play video:", err);
          setDebugInfo(`Manual play failed: ${err.message}`);
          setError("Cannot play video. Check permissions.");
        });
    }
  };

  return (
    <div className="flex justify-center items-center h-screen bg-gray-100 relative">
      {isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 z-10">
          <div className="text-white">Connecting to stream...</div>
        </div>
      )}
      <video
        ref={videoRef}
        autoPlay
        playsInline
        muted
        className="w-full max-w-[800px] h-auto border bg-black"
        // controls={false}
        // onClick={handleVideoClick}
      />
      {error && !isStreamActive && (
        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white z-20">
          <div className="text-center">
            <p>{error}</p>
            <p className="text-sm mt-2">Waiting for video stream</p>
          </div>
        </div>
      )}
      {error && isStreamActive && (
        <div 
          className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white cursor-pointer z-20"
          onClick={handleVideoClick}
        >
          <div className="text-center">
            <p>{error}</p>
            <p className="text-sm mt-2">Click to play video</p>
          </div>
        </div>
      )}
      {/* Debug panel */}
      <div className="absolute top-4 left-4 bg-black bg-opacity-70 text-white p-3 rounded text-xs max-w-md z-30">
        <div className="font-bold mb-2">Debug Info:</div>
        <div className="overflow-auto max-h-32">{debugInfo}</div>
        <div className="mt-2">
          Status: {isLoading ? "Connecting..." : isStreamActive ? "Streaming" : "Connected"}
        </div>
      </div>
    </div>
  );
}

